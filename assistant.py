import os
import sys
import requests
from dotenv import load_dotenv

import csv
from collections import Counter

############  SETUP  ############

MODEL = "openai/gpt-5.2" #model to use

def get_api_key (): 

    """retrives api key from evironment and returns it as a string"""

    load_dotenv() # load environment variables from .env file

    api_key = os.getenv("OPENROUTER_API_KEY") #assign api variable

    if not api_key: #fails if key doesn't exist
        print ("Error! Missing API Key.", file=sys.stderr)
        sys.exit(1)

    return api_key

def call_openrouter_chat (api_key, messages, model = MODEL, temperature = 0.2):
    """
    Sends a chat completion request to the API and returns the assistant’s reply
    as a string.
    As a side note, `messages` is a list of dictionaries representing a conversation. Each
    dictionary is one message, where we specify the role (system, user, or assistant)
    and the actual text content, where we tell the model what task it's doing and provide the user's input content.
    """

    URL = "https://openrouter.ai/api/v1/chat/completions" # api endpoint

    headers = {
        # this is the metadata (specifications) of our request
        
        "Authorization": f"Bearer {api_key}", # authenticates request
        "Content-Type": "application/json" # tells server that request body is JSON
     } 
    
    payload = {
        # data that the api actually processes

        "model": model, # model we use
        "messages": messages, # conversation history
        "temperature": temperature # model output randomness value
    } 
    
    #sending a POST request (data to server) and getting response
    resp = requests.post (URL, headers=headers, json=payload, timeout=60) 

    #raise error if api did not return a successful response
    if resp.status_code != 200:
        raise RuntimeError(
            f"OpenRouter error {resp.status_code}: {resp.text[:500]}"
        )

    # parse json response
    data = resp.json()

    # return assistant's reply
    return data['choices'][0]['message']['content'] # returns first proposed response

def multiline_prompting ():
    """Allows the user to prompt multiple lines"""

    lines = []
    while True:
        line = input()
        command = line.strip().upper()

        if command == "DONE":
            return "\n".join(lines).strip()

        if command == "QUIT":
            return "QUIT"

        lines.append(line)

############ FEATURES ############

# messages generated by ChatGPT to avoid prompt engineering myself

def code_explainer(api_key):
    """
    User inputs code and gets a clear explanation of what it does
    """
    print("Paste code to explain.")
    print("Type DONE to finish a snippet, or QUIT to exit.\n")
    print("Type QUIT on a new line to exit.\n")


    while True:
        print ("Enter snippet.")
        code = multiline_prompting()

        # Exit condition
        if code.strip().upper() == "QUIT":
            print("Exiting code explainer.")
            break

        if not code:
            print("No code provided. Try again.\n")
            continue

        messages = [
            {
                "role": "system",
                "content": (
                    "You are a helpful programming assistant. "
                    "Explain the given code clearly and accurately. "
                    "Describe what it does, how it works, and the purpose of key parts. "
                    "Do not assume missing context or invent behavior."
                ),
            },
            {
                "role": "user",
                "content": f"Explain the following code:\n\n{code}",
            },
        ]

        explanation = call_openrouter_chat(
            api_key=api_key,
            messages=messages,
        )

        print("\n" + "-" * 60)
        print("CODE EXPLANATION")
        print("-" * 60)
        print(explanation)
        print("-" * 60 + "\n")

def translate_text(api_key):
    """
    Prompts the user for text and source/target languages, then prints a translation.
    """

    print("Language Translator")
    print("Type DONE to finish entering text.")
    print("Type QUIT on a new line to exit.\n")

    while True:
        source_lang = input(
            "Source language (e.g., English, French, Spanish) or 'auto': "
        ).strip()
        if not source_lang:
            source_lang = "auto"

        # Allow quitting before asking for target language
        if source_lang.upper() == "QUIT":
            print("Exiting translator.")
            break

        target_lang = input(
            "Target language (e.g., English, French, Spanish): "
        ).strip()
        if not target_lang:
            print("Target language is required.\n")
            continue

        if target_lang.upper() == "QUIT":
            print("Exiting translator.")
            break

        print("\nEnter the text you want to translate.")
        text = multiline_prompting()

        # Exit condition after multiline input
        if text.strip().upper() == "QUIT":
            print("Exiting translator.")
            break

        if not text:
            print("No text provided. Try again.\n")
            continue

        messages = [
            {
                "role": "system",
                "content": (
                    "You are a precise translator. "
                    "Translate the user's text accurately while preserving meaning, tone, and formatting. "
                    "Do not add extra commentary—only output the translation."
                ),
            },
            {
                "role": "user",
                "content": (
                    f"Translate from {source_lang} to {target_lang}.\n\n"
                    f"TEXT:\n{text}"
                ),
            },
        ]

        translation = call_openrouter_chat(
            api_key=api_key,
            messages=messages,
        )

        print("\n" + "-" * 60)
        print("TRANSLATION")
        print("-" * 60)
        print(translation)
        print("-" * 60 + "\n")

def suggest_recipes(api_key):
    """
    Prompts the user for ingredients and preferences, then prints a few recipe ideas.
    """

    print("Recipe Suggester")
    print("Enter ingredients (one per line). Type DONE to finish a set.")
    print("Type QUIT on a new line to exit.\n")

    while True:
        print("Enter ingredients for this request:")
        ingredients_text = multiline_prompting()

        # Exit condition after multiline input
        if ingredients_text.strip().upper() == "QUIT":
            print("Exiting recipe suggester.")
            break

        if not ingredients_text:
            print("No ingredients provided. Try again.\n")
            continue

        # Optional preferences to make results better without complexity
        cuisine = input("Cuisine preference (optional, e.g., Italian, Asian, none): ").strip()
        if cuisine.upper() == "QUIT":
            print("Exiting recipe suggester.")
            break

        time_limit = input("Max cooking time (optional, e.g., 15 min, 30 min, none): ").strip()
        if time_limit.upper() == "QUIT":
            print("Exiting recipe suggester.")
            break

        dietary = input("Dietary constraints (optional, e.g., vegetarian, halal, none): ").strip()
        if dietary.upper() == "QUIT":
            print("Exiting recipe suggester.")
            break

        # Build a concise preferences string for the model
        prefs = []
        if cuisine and cuisine.lower() != "none":
            prefs.append(f"Cuisine: {cuisine}")
        if time_limit and time_limit.lower() != "none":
            prefs.append(f"Time limit: {time_limit}")
        if dietary and dietary.lower() != "none":
            prefs.append(f"Dietary: {dietary}")

        prefs_text = "\n".join(prefs) if prefs else "No preferences."

        messages = [
            {
                "role": "system",
                "content": (
                    "You are a helpful cooking assistant. "
                    "Given a list of ingredients, suggest 3 to 5 realistic recipes. "
                    "Keep them simple, include brief steps, and avoid rare ingredients. "
                    "If an extra ingredient is needed (like salt, oil), assume it's a common pantry item."
                ),
            },
            {
                "role": "user",
                "content": (
                    f"Ingredients:\n{ingredients_text}\n\n"
                    f"Preferences:\n{prefs_text}\n\n"
                    "Return 3-5 options. For each: name, why it fits, ingredients used, and 4-7 short steps."
                ),
            },
        ]

        ideas = call_openrouter_chat(api_key=api_key, messages=messages)

        print("\n" + "-" * 60)
        print("RECIPE IDEAS")
        print("-" * 60)
        print(ideas)
        print("-" * 60 + "\n")

def supportive_coach(api_key):
    print("Supportive Coach (non-clinical)")
    print("Talk about what's on your mind. Type DONE to send a message.")
    print("Type QUIT on a new line to end the session.\n")

    # Conversation memory: the model only 'remembers' what we resend in messages
    messages = [
        {
            "role": "system",
            "content": (
                "You are a supportive wellness assistant, not a therapist or medical professional. "
                "Listen carefully, reflect the user's feelings, and offer gentle, practical coping suggestions. "
                "Ask one or two helpful questions when appropriate. "
                "Do not diagnose conditions, do not provide medical/clinical advice, and do not discuss self-harm methods. "
                "Encourage reaching out to trusted people (friends, family, a counselor/doctor) when appropriate. "
                "Keep responses calm, respectful, and grounded."
            ),
        }
    ]

    while True:
        user_text = multiline_prompting()

        # Allow quitting at any time
        if user_text.strip().upper() == "QUIT":
            print("Take care. Session ended.")
            break

        if not user_text:
            print("No message provided. Type something, or QUIT to exit.\n")
            continue

        # Add the user's message to the conversation history
        messages.append({"role": "user", "content": user_text})

        # Generate assistant response
        reply = call_openrouter_chat(
            api_key=api_key,
            messages=messages,
            temperature=0.4,  # slightly warmer tone
        )

        # Add assistant reply to history so the next turn has context
        messages.append({"role": "assistant", "content": reply})

        print("\n" + "-" * 60)
        print(reply)
        print("-" * 60 + "\n")


def mock_interviewer(api_key):
    """
    Runs a continuous mock interview.
    The assistant asks questions, the user answers, and the assistant gives brief feedback.
    Type QUIT on a new line to exit.
    """

    print("Mock Interviewer")
    print("Answer the questions. Type DONE to submit each answer.")
    print("Type QUIT on a new line to end the interview.\n")

    role = input("Role you're interviewing for (e.g., SWE intern, analyst, none): ").strip()
    if not role:
        role = "general internship"

    focus = input("Focus (behavioral/technical/mixed, default=mixed): ").strip().lower()
    if focus not in {"behavioral", "technical", "mixed"}:
        focus = "mixed"

    # Conversation history matters here: the interviewer should remember what was asked/answered
    messages = [
        {
            "role": "system",
            "content": (
                "You are a professional interviewer running a mock interview. "
                "Ask ONE question at a time, then wait for the user's answer. "
                "After the user answers, give brief feedback (2-5 bullets) on clarity, structure, and impact, "
                "and then ask the next question. "
                "Keep it realistic and supportive. "
                "Do not invent user experiences; work with what the user says."
            ),
        },
        {
            "role": "user",
            "content": (
                f"Start a {focus} mock interview for a {role} role. "
                "Ask the first question now."
            ),
        },
    ]

    # Ask the first question
    first = call_openrouter_chat(api_key=api_key, messages=messages, temperature=0.3)
    print("\n" + "-" * 60)
    print(first)
    print("-" * 60 + "\n")
    messages.append({"role": "assistant", "content": first})

    while True:
        print("Your answer:")
        answer = multiline_prompting()

        if answer.strip().upper() == "QUIT":
            print("Interview ended. Good work.")
            break

        if not answer:
            print("No answer provided. Try again, or type QUIT to exit.\n")
            continue

        # Add user answer
        messages.append({"role": "user", "content": answer})

        # Get feedback + next question
        interviewer_reply = call_openrouter_chat(api_key=api_key, messages=messages, temperature=0.3)

        print("\n" + "-" * 60)
        print(interviewer_reply)
        print("-" * 60 + "\n")

        # Add assistant reply to keep context
        messages.append({"role": "assistant", "content": interviewer_reply})


def debate_partner(api_key):
    """
    Runs a back-and-forth debate where the assistant plays devil's advocate.
    """

    print("Debate Partner (Devil's Advocate)")
    print("State an opinion or claim to debate.")
    print("Type DONE to submit each message.")
    print("Type QUIT to end the debate.\n")

    messages = [
        {
            "role": "system",
            "content": (
                "You are a respectful but challenging debate partner. "
                "Your role is to question assumptions, present counterarguments, "
                "and ask probing follow-up questions. "
                "Remain polite, logical, and constructive. "
                "Do not attack the user personally."
            ),
        }
    ]

    # Initial claim
    print("Your initial claim:")
    claim = multiline_prompting()

    if claim.strip().upper() == "QUIT":
        print("Debate ended.")
        return

    messages.append({"role": "user", "content": claim})

    # Assistant responds first
    reply = call_openrouter_chat(api_key=api_key, messages=messages, temperature=0.4)
    print("\n" + "-" * 60)
    print(reply)
    print("-" * 60 + "\n")
    messages.append({"role": "assistant", "content": reply})

    while True:
        print("Your response:")
        user_reply = multiline_prompting()

        if user_reply.strip().upper() == "QUIT":
            print("Debate ended.")
            break

        if not user_reply:
            print("No response provided. Try again.\n")
            continue

        messages.append({"role": "user", "content": user_reply})

        reply = call_openrouter_chat(api_key=api_key, messages=messages, temperature=0.4)

        print("\n" + "-" * 60)
        print(reply)
        print("-" * 60 + "\n")

        messages.append({"role": "assistant", "content": reply})


def menu():
    """Displays the main menu and returns the user's choice."""
    print("\n" + "=" * 60)
    print("Personal AI Assistant")
    print("=" * 60)
    print("1) Code Explainer")
    print("2) Language Translator")
    print("3) Recipe Suggester")
    print("4) Supportive Coach")
    print("5) Mock Interviewer")
    print("6) Devil's advocate")
    print("7) Quit")
    return input("Choose an option: ").strip()


def main():
    """Main program loop: load API key once, then route menu choices to features."""
    api_key = get_api_key()

    while True:
        choice = menu()

        if choice == "1":
            code_explainer(api_key)
        elif choice == "2":
            translate_text(api_key)
        elif choice == "3":
            suggest_recipes(api_key)
        elif choice == "4":
            supportive_coach(api_key)
        elif choice == "5":
            mock_interviewer(api_key)
        elif choice == "6":
            debate_partner(api_key)
        elif choice == "7":
            print("Bye!")
            break
        else:
            print("Invalid choice. Please select 1-7.")


if __name__ == "__main__":
    main()